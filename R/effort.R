#' Boat effort per trip
#'
#' [boat_effort_per_trip()] generates a [tibble][tibble::tibble-package]
#' encoding the boat effort per individual boat trip, i.e. how much time spent
#' on a specific grid cell or detector, per trip.
#'
#' @param boat_trips A [tibble][tibble::tibble-package] of track data (boat
#'   trips). Data should be aggregated on a specific time interval, e.g.
#'   minutes.
#' @param grid A [RasterLayer][raster::raster] object.
#' @param coordinates The type of coordinates in the output: `"utm"` (default)
#'   or `"longlat"`.
#'
#' @return A [tibble][tibble::tibble-package] of five plus n columns, where n
#'   is the number of occasions. The first five columns are: `index`, the
#'   detector identifier or index; `easting` and `northing`, or `longitude` and
#'   `latitude`.
#'
#' @examples
#' boat_effort_per_trip()
#'
#' @importFrom rlang .data
#' @export
boat_effort_per_trip <-
  function(boat_trips = azores.fkw::boat_trips_by_min,
           grid = create_grid(),
           coordinates = c("utm", "longlat")) {

  if (!rlang::has_name(boat_trips, "trip"))
    stop("`boat_trips` must have a column named trip")

  if (!rlang::has_name(boat_trips, "longitude"))
    stop("`boat_trips` must have a column named longitude")

  if (!rlang::has_name(boat_trips, "latitude"))
    stop("`boat_trips` must have a column named latitude")

  coordinates <- match.arg(coordinates)

  # Find detectors for any given moment of `boat_trips`
  detectors <- find_grid_cells(points = boat_trips, grid = grid)

  effort <-
    boat_trips["trip"] |>
    dplyr::bind_cols(detectors) |>
    dplyr::count(.data$trip,
                 .data$index,
                 .data$longitude,
                 .data$latitude,
                 name = "total_minutes") |>
    tidyr::pivot_wider(
      names_from = c("trip"),
      values_from = "total_minutes",
      values_fill = 0L
    )

  # Change effort to use UTM instead of Longitude/Latitude coordinates
  if (identical(coordinates, "utm")) {
    longlat <-
      dplyr::rename(effort[c("latitude", "longitude")],
                    lat = .data$latitude,
                    lon = .data$longitude)

    utm <- longlat_to_utm(longlat)
    effort <- tibble::tibble(effort["index"], utm[c("easting", "northing")], effort[-(1:3)])
  }

  effort
}

#' Boat effort per average trip
#'
#' [boat_effort_per_avg_trip()] calculates the boat effort per trip on average.
#' This function takes the results per trip as generated by
#' [boat_effort_per_trip()] and calculates the mean per grid cell / detector.
#'
#' @param boat_effort_per_trip A tibble as output by [boat_effort_per_trip()].
#'
#' @returns A tibble of four columns: `index` (index of the grid cell /
#'   detector), UTM coordinates (`easting` and `northing`), and the average boat
#'   effort per trip per grid point (`boat_effort`).
#'
#' @examples
#' boat_effort_per_avg_trip()
#'
#' @export
boat_effort_per_avg_trip <- function(boat_effort_per_trip = azores.fkw::boat_effort_per_trip()) {
  boat_effort_per_trip |>
    dplyr::rowwise() |>
    dplyr::mutate(boat_effort = mean(dplyr::c_across(dplyr::matches("\\d{4}")), na.rm = TRUE)) |>
    dplyr::select(c("index", "easting", "northing", "boat_effort")) |>
    dplyr::ungroup()
}

#' Total boat effort per grid point
#'
#' [boat_effort_for_all_trips()] calculates the total boat effort per grid
#' point. This function takes the results per trip as generated by
#' [boat_effort_per_trip()] and calculates the sum of all boat efforts across
#' all trips per grid cell / detector.
#'
#' @param boat_effort_per_trip A tibble as output by [boat_effort_per_trip()].
#'
#' @returns A tibble of four columns: `index` (index of the grid cell /
#'   detector), UTM coordinates (`easting` and `northing`), and the total (sum)
#'   boat effort per trip per grid point (`boat_effort`).
#'
#' @examples
#' boat_effort_for_all_trips()
#'
#' @export
boat_effort_for_all_trips <- function(boat_effort_per_trip = azores.fkw::boat_effort_per_trip()) {
  boat_effort_per_trip |>
    dplyr::rowwise() |>
    dplyr::mutate(boat_effort = sum(dplyr::c_across(dplyr::matches("\\d{4}")), na.rm = TRUE)) |>
    dplyr::select(c("index", "easting", "northing", "boat_effort")) |>
    dplyr::ungroup()
}

#' Logistic function
#'
#' [logistic()] returns the logistic function y-values as a function of
#' distance `d` (x-value). The parameter `d_half` controls where the function
#' is `0.5`. The rate parameter tweaks how quickly the y-values decrease over
#' distance.
#'
#' @param d Distance, x-values to the logistic function.
#' @param d_half Distance at which the logistic function is `0.5`, i.e. half the
#' maximum y-value (that happens at `d = 0`).
#' @param rate A parameter that controls how quickly the y-values decrease over
#' distance.
#'
#' @returns A numeric vector of y-values for the given distances (as passed
#' in `d`).
#'
#' @examples
#' logistic(d = seq(0, 40))
#'
#' @export
logistic <- function(d, d_half = 20, rate = 0.5) {
  1 / (1 + exp(rate * (d - d_half)))
}

#' Logistic function in 2D
#'
#' [logistic_2d()] is analogous to [logistic()] but calculates the logistic
#' function y-values for a set of 2D points (provided as a matrix). The origin
#' point can be defined with `ref_point`, which by default is the location of
#' Vigia da Queimada coordinates.
#'
#' @param points A numeric matrix of 2D points, where each row corresponds to a
#'   point. First column is longitude, and second column is latitude, in decimal
#'   degrees.
#'
#' @param ref_point A numeric vector of two elements (longitude and latitude)
#' indicating the point of origin of the logistic function in 2 dimensions.
#'
#' @returns A numeric vector of logistic y-values, one for each point provided
#' in the input matrix `points`.
#'
#' @examples
#'
#' p_sao_mateus <- c(-28.444493, 38.420308)
#' p_queimada <- c(-28.23645, 38.38496)
#' p_terras <- c(-28.231384, 38.385289)
#'
#' points <- matrix(c(p_sao_mateus, p_queimada, p_terras), ncol = 2, byrow = TRUE)
#'
#' logistic_2d(points)
#'
#' @export
logistic_2d <- function(points, ref_point = c(-28.23645, 38.38496)) {
  distance <- as.vector(geosphere::distm(x = ref_point, y = points) / 1000)
  logistic(d = distance, d_half = 20, rate = 0.5)
}

#' Determine lookout score
#'
#' @description
#'
#' [lookout_score()] determines the lookout "effort score" based on three
#' key aspects:
#'
#' - `lookout_position`: The lookout position determines the point around
#' which the effort score is highest. This position is by default the position
#' of the lookout at Vigia da Queimada, Pico Island, Azores. These coordinates
#' are expected in longitude and latitude, in decimal degrees.
#'
#' - `lookout_detection_fn`: The lookout detection function is a monotonic
#' decreasing function that models the effort score as a function of the
#' distance from the lookout position. By default this function is
#' `logistic2()`, which is the same model as used by Derville et al. (2018).
#'
#' - `lookout_obs_area_sf`: The lookout observation area is a polygon that
#' defines the region where lookout effort scores are either taken as is, or
#' are set to zero if outside of the region defined by this polygon. This region
#' is expected to be an `sf` object, namely of type `POLYGON`.
#'
#' @param lookout_position Lookout position, a numeric vector with longitude
#' and latitude, in decimal degrees.
#' @param lookout_detection_fn Lookout detection function. A function whose
#' x-value is the distance to the `lookout_position`, and whose y-value is
#' the "effort score".
#' @param lookout_obs_area_sf The observation area for the lookout, passed as
#' an `sf` object, namely of type `POLYGON`.
#' @param grid A [RasterLayer][raster::raster] object. By default returns a grid
#'   encompassing the study area, i.e., off the coast of Pico, Faial and SÃ£o
#'   Jorge, Azores, Portugal.
#'
#' @returns A tibble of lookout scores for each of the grid points (as specified
#' in `grid`). The effort score is provided in two scales:
#'
#' - `lookout_score`: The score as directly calculated from the detection
#' function (`lookout_detection_fn`).
#'
#' - `lookout_score_normalized`: A normalized score obtained by dividing
#' `lookout_score` by the total lookout score over the study area. This variable
#' can be readily used and multiplied by time scaling factor, allowing the
#' calculation of an effective effort, e.g. if the lookout watches the sea for
#' 180 minutes straight, i.e. for the typical time duration of a boat trip, then
#' the normalized score can be multiplied by 180 to determine the actual effort
#' per boat trip, in minutes.
#'
#' @export
lookout_score <- function(lookout_position = c(-28.23645, 38.38496),
                                     lookout_detection_fn = logistic_2d,
                                     lookout_obs_area_sf = lookout_obs_area(),
                                     grid = create_grid()) {
  grid_points_df <- grid_centroids(grid = grid)
  grid_points_m <- as.matrix(grid_points_df[, 2:3])
  lookout_score <- lookout_detection_fn(grid_points_m, ref_point = lookout_position)
  grid_points_df2 <- tibble::add_column(grid_points_df, lookout_score)

  # Convert grid_points_df2 to an sf object
  grid_points_df2_sf <- grid_points_df2 |>
    sf::st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326,
      agr = "constant"
    )

  # Perform spatial join to identify points within the polygon
  grid_points_within_polygon <- sf::st_join(grid_points_df2_sf, lookout_obs_area_sf, join = sf::st_within)
  avg_trip_time <- 180

  # Set lookout_score to zero for points outside the polygon
  grid_points_df3 <- grid_points_df2 |>
    dplyr::mutate(lookout_score = ifelse(is.na(grid_points_within_polygon$name), 0, lookout_score)) |>
    dplyr::mutate(lookout_score_normalized = lookout_score / sum(lookout_score))

  effort <- grid_points_df3


  longlat <-
    dplyr::rename(effort[c("latitude", "longitude")], lat = "latitude", lon = "longitude")

  utm <- longlat_to_utm(longlat)
  lookout_score_tbl <- tibble::tibble(effort["index"], utm[c("easting", "northing")], effort[-1])
  lookout_score_tbl
}

#' Lookout effort per boat trip
#'
#' [lookout_effort_by_trip()] takes lookout scores and boat efforts per trip
#' in minutes, and calculates the lookout effort per trip. Essentially, the
#' lookout score is always the same but it is re-scaled here according to the
#' time the boat spent on each position. The boat trip duration is used as
#' a proxy for the lookout watching time.
#'
#' @param lookout_score_tbl A tibble with lookout scores. See [lookout_score()].
#' @param boat_effort_per_trip_tbl A tibble with boat effort per trip, in
#'   minutes, see [boat_effort_per_trip()].
#'
#' @returns A tibble where boat effort in minutes has been converted to lookout
#' effort, also in minutes.
#'
#' @importFrom rlang .data
lookout_effort_by_trip <- function(lookout_score_tbl = lookout_score(),
                                   boat_effort_per_trip_tbl = boat_effort_per_trip()) {

  joined_tbl <- dplyr::left_join(boat_effort_per_trip_tbl,
                                 lookout_score_tbl,
                                 by = c("index", "easting", "northing"))

  dplyr::mutate(joined_tbl,
                dplyr::across(
                  dplyr::matches("\\d{4}"),
                  ~ .x * .data$lookout_score_normalized
                )) |>
    dplyr::select(-c("lookout_score", "lookout_score_normalized")) |>
    dplyr::relocate(.data$longitude, .data$latitude, .after = "northing")

}

#' Lookout effort per average trip
#'
#' [lookout_effort_per_avg_trip()] calculates the lookout effort per trip on average.
#' This function takes the results generated by
#' [lookout_score()] and calculates average lookout effort by simply multiplying
#' the effort score by the boat trip average duration (defaults to 180 min).
#'
#' @param lookout_score A tibble as output by [lookout_score()].
#' @param trip_avg_time Trip average time. Default is 180 minutes.
#'
#' @returns A tibble with the same structure as the value returned by
#'   [lookout_score()] with an extra column: `lookout_effort`, i.e. the lookout
#'   effort per average trip, in minutes.
#'
#' @examples
#' lookout_effort_per_avg_trip()
#'
#' @export
lookout_effort_per_avg_trip <- function(lookout_score = azores.fkw::lookout_score(),
                                        trip_avg_time = 180) {
  lookout_score |>
    dplyr::mutate(lookout_effort = .data$lookout_score_normalized * trip_avg_time)
}

#' Lookout effort for all trips
#'
#' [lookout_effort_for_all_trips()] calculates the lookout effort per trip on
#' average. This function takes the results generated by [lookout_score()] and
#' calculates the total lookout effort for the number of trips given in
#' `ntrips`.
#'
#' @param lookout_score A tibble as output by [lookout_score()].
#' @param trip_avg_time Trip average time. Default is 180 minutes.
#' @param ntrips Number of trips. Default is taken from the number of trips
#' as existing in the value returned by [boat_effort_per_trip()].
#'
#' @returns A tibble with the same structure as the value returned by
#'   [lookout_score()] with an extra column: `lookout_effort`, i.e. the total
#'   lookout effort corresponding to the number of trips given in `ntrips`.
#'
#' @examples
#' lookout_effort_for_all_trips()
#'
#' @export
lookout_effort_for_all_trips <- function(lookout_score = azores.fkw::lookout_score(),
                                         trip_avg_time = 180,
                                         ntrips = ncol(boat_effort_per_trip()) - 3L) {
  lookout_effort_per_avg_trip(lookout_score = lookout_score, trip_avg_time = trip_avg_time) |>
    dplyr::mutate(lookout_effort = .data$lookout_effort * ntrips)
}

#' Combined effort
#'
#' [combined_effort_for_all_trips()] determines the combined effort, i.e. the total of boat
#' and lookout efforts for all the study duration period.
#'
#' @param boat_effort A tibble as returned by [boat_effort_for_all_trips()].
#' @param lookout_effort A tibble as returned by [lookout_effort_for_all_trips()].
#'
#' @returns A tibble with one row per spatial position, with the following
#'   columns:
#'
#' - `index`: An index for each grid position / detector.
#' - `easting`: Easting coordinate.
#' - `northing`: Northing coordinate.
#' - `longitude`: Longitude, in decimal degrees.
#' - `latitude`: Latitude, in decimal degrees.
#' - `lookout_score`: Lookout score, as calculated with [logistic_2d()].
#' - `lookout_score_normalized`: Normalized lookout score, the same as
#'   `lookout_score` but normalized for the total over the score over the whole
#'   study area.
#' - `lookout_effort`: Total lookout effort, in minutes, for the whole study
#'    duration time.
#' - `boat_effort`: Total boat effort, in minutes, for the whole study
#'    duration time.
#' - `combined_effort`: The sum of `lookout_effort` and `boat_effort`, in
#'   minutes, for the whole study duration time.
#'
#' @examples
#'
#' combined_effort_for_all_trips()
#'
#' @export
combined_effort_for_all_trips <- function(boat_effort = boat_effort_for_all_trips(),
                            lookout_effort = lookout_effort_for_all_trips()) {
  dplyr::left_join(lookout_effort,
                   boat_effort,
                   by = c("index", "easting", "northing"), ) |>
    dplyr::mutate(boat_effort = dplyr::if_else(is.na(.data$boat_effort), 0L, .data$boat_effort)) |>
    dplyr::mutate(combined_effort = .data$boat_effort + .data$lookout_effort)
}

#' [combined_effort_per_trip()] determines the combined effort, i.e. the total of boat
#' and lookout efforts for every trip.
#'
#' @param boat_effort_per_trip A tibble of boat effort per individual trip. See [boat_effort_per_trip()].
#' @param lookout_effort_per_avg_trip A tibble of lookout effort per individual trip. See [lookout_effort_per_avg_trip].
#'
#' @returns A [tibble][tibble::tibble-package] of five plus n columns, where n
#'   is the number of occasions. The first five columns are: `index`, the
#'   detector identifier or index; `easting` and `northing`, or `longitude` and
#'   `latitude`.
#'
#' @importFrom rlang .data
#' @export
combined_effort_per_trip <- function(boat_effort_per_trip = azores.fkw::boat_effort_per_trip(),
                                     lookout_effort_per_avg_trip = azores.fkw::lookout_effort_per_avg_trip()) {

  lookout_effort_per_avg_trip |>
    dplyr::left_join(boat_effort_per_trip, by = c("index", "easting", "northing")) |>
    dplyr::mutate(dplyr::across(dplyr::matches("^\\d{4}"), ~ tidyr::replace_na(.x, replace = 0))) |>
    dplyr::mutate(dplyr::across(dplyr::matches("^\\d{4}"), ~ .data$lookout_effort + .x)) |>
    dplyr::select(-dplyr::starts_with("lookout_"))

}
